corexykins.c:56:int kinematicsHome(EmcPose *world
corexykins.c:63:    return kinematicsForward(joint, world, fflags, iflags);
genhexkins.c:25:  to the base, in base (world) coordinates.
genhexkins.c:484:/* the inverse kinematics take world coordinates and determine joint values,
genhexkins.c:486:   flags are set to indicate their value appropriate to the world coordinates
genhexkins.c:513:       to world coordinates */
genhexkins.h:29:/* Default position of base strut ends in base (world) coordinates */
genhexkins.h:75:/* Default unit vectors of base joints axes in world coordinates */
genserfuncs.c:312:                            EmcPose * world,
genserfuncs.c:346:    rpy.y = world->c * PM_PI / 180;
genserfuncs.c:347:    rpy.p = world->b * PM_PI / 180;
genserfuncs.c:348:    rpy.r = world->a * PM_PI / 180;
genserfuncs.c:351:    pos->tran.x = world->tran.x;
genserfuncs.c:352:    pos->tran.y = world->tran.y;
genserfuncs.c:353:    pos->tran.z = world->tran.z;
genserfuncs.c:356:    if (total_joints > 6) world->u = joint[6];
genserfuncs.c:357:    if (total_joints > 7) world->v = joint[7];
genserfuncs.c:358:    if (total_joints > 8) world->w = joint[8];
genserfuncs.c:360:    // pos will be the world location
genserfuncs.c:370:    world->tran.x = pos->tran.x;
genserfuncs.c:371:    world->tran.y = pos->tran.y;
genserfuncs.c:372:    world->tran.z = pos->tran.z;
genserfuncs.c:373:    world->a = rpy.r * 180 / PM_PI;
genserfuncs.c:374:    world->b = rpy.p * 180 / PM_PI;
genserfuncs.c:375:    world->c = rpy.y * 180 / PM_PI;
genserfuncs.c:378:// rtapi_print("genserKinematicsForward(world: %f %f %f %f %f %f)\n", world->tran.x, world->tran.y, world->tran.z, world->a, world->b, world->c);
genserfuncs.c:406:int genserKinematicsInverse(const EmcPose * world,
genserfuncs.c:430:    // rtapi_print("kineInverse(world: %f %f %f %f %f %f)\n",
genserfuncs.c:431:    //      world->tran.x, world->tran.y, world->tran.z, world->a, world->b, world->c);
genserfuncs.c:443:    rpy.y = world->c * PM_PI / 180;
genserfuncs.c:444:    rpy.p = world->b * PM_PI / 180;
genserfuncs.c:445:    rpy.r = world->a * PM_PI / 180;
genserfuncs.c:448:    haldata->pos->tran.x = world->tran.x;
genserfuncs.c:449:    haldata->pos->tran.y = world->tran.y;
genserfuncs.c:450:    haldata->pos->tran.z = world->tran.z;
genserfuncs.c:527:        if (total_joints > 6) joints[6] = world->u;
genserfuncs.c:528:        if (total_joints > 7) joints[7] = world->v;
genserfuncs.c:529:        if (total_joints > 8) joints[8] = world->w;
genserfuncs.c:552:            //     world->tran.x, world->tran.y, world->tran.z, world->a, world->b, world->c);
genserkins.h:93:                                go_pose * world);
genserkins.h:96:                                const go_pose * world,
genserkins.h:147:                                   EmcPose * world,
genserkins.h:151:extern int genserKinematicsInverse(const EmcPose * world,
kinematics.h:24:  KINEMATICS_IDENTITY means that the joints and world coordinates are the
kinematics.h:26:  changing from joint to world mode and vice versa. Also, the EMC will set
kinematics.h:27:  the actual world position to be the actual joint positions (not commanded)
kinematics.h:36:  joint to world mode at the home position.
kinematics.h:39:  Like KINEMATICS_IDENTITY, the EMC will allow changing between world and
kinematics.h:42:  to compute actual world coordinates from actual joint values.
kinematics.h:53:   can resolve ambiguities in the world coordinates for a given joint set,
kinematics.h:64:   can resolve ambiguities in the joint angles for a given world coordinate,
kinematics.h:74:/* the forward kinematics take joint values and determine world coordinates,
kinematics.h:79:                             struct EmcPose * world,
kinematics.h:83:/* the inverse kinematics take world coordinates and determine joint values,
kinematics.h:85:   flags are set to indicate their value appropriate to the world coordinates
kinematics.h:87:extern int kinematicsInverse(const struct EmcPose * world,
kinematics.h:98:extern int kinematicsHome(struct EmcPose * world,
kinematics.h:151:                                     struct EmcPose * world,
kinematics.h:155:extern int identityKinematicsInverse(const struct EmcPose * world,
kinematics.h:179:                                  struct EmcPose * world,
kinematics.h:183:extern int userkKinematicsInverse(const struct EmcPose * world,
pentakins.c:225:       to world coordinates */
pentakins.c:363:/* the inverse kinematics take world coordinates and determine joint values,
pentakins.c:365:   flags are set to indicate their value appropriate to the world coordinates
pentakins.h:21:/* Default position of base strut ends in base (world) coordinates */
pumakins.c:39:                                 EmcPose * world,
pumakins.c:50:   PmPose worldPose;
pumakins.c:163:   /* convert hom.rot to world->quat */
pumakins.c:164:   pmHomPoseConvert(&hom, &worldPose);
pumakins.c:165:   pmQuatRpyConvert(&worldPose.rot,&rpy);
pumakins.c:166:   world->tran = worldPose.tran;
pumakins.c:167:   world->a = rpy.r * 180.0/PM_PI;
pumakins.c:168:   world->b = rpy.p * 180.0/PM_PI;
pumakins.c:169:   world->c = rpy.y * 180.0/PM_PI;
pumakins.c:176:static int pumaKinematicsInverse(const EmcPose * world,
pumakins.c:182:   PmPose worldPose;
pumakins.c:209:   worldPose.tran = world->tran;
pumakins.c:210:   rpy.r = world->a*PM_PI/180.0;
pumakins.c:211:   rpy.p = world->b*PM_PI/180.0;
pumakins.c:212:   rpy.y = world->c*PM_PI/180.0;
pumakins.c:213:   pmRpyQuatConvert(&rpy,&worldPose.rot);
pumakins.c:214:   pmPoseHomConvert(&worldPose, &hom);
rotatekins.c:57:int kinematicsHome(EmcPose * world,
rotatekins.c:65:    return kinematicsForward(joint, world, fflags, iflags);
scarakins-modified.c:77:                      EmcPose * world,
scarakins-modified.c:88:/* convert angles into world coords */
scarakins-modified.c:101:    world->tran.x = x;
scarakins-modified.c:102:    world->tran.y = y;
scarakins-modified.c:103:    world->tran.z = z;
scarakins-modified.c:104:    world->a = joint[4];
scarakins-modified.c:105:    world->b = joint[5];
scarakins-modified.c:110:static int scaraKinematicsInverse(const EmcPose * world,
scarakins-modified.c:120:    x = world->tran.x;
scarakins-modified.c:121:    y = world->tran.y;
scarakins-modified.c:122:    z = world->tran.z;
scarakins-modified.c:123:    c = world->c;
scarakins-modified.c:162:    joint[4] = world->a;
scarakins-modified.c:163:    joint[5] = world->b;
scarakins.c:77:                      EmcPose * world,
scarakins.c:89:/* convert angles into world coords */
scarakins.c:104:    world->tran.x = x;
scarakins.c:105:    world->tran.y = y;
scarakins.c:106:    world->tran.z = z;
scarakins.c:107:    world->c = c * 180 / PM_PI;
scarakins.c:109:    world->a = joint[4];
scarakins.c:110:    world->b = joint[5];
scarakins.c:115:static int scaraKinematicsInverse(const EmcPose * world,
scarakins.c:125:    x = world->tran.x;
scarakins.c:126:    y = world->tran.y;
scarakins.c:127:    z = world->tran.z;
scarakins.c:128:    c = world->c;
scarakins.c:167:    joint[4] = world->a;
scarakins.c:168:    joint[5] = world->b;
scorbot-kins.c:129:// "cartesian" coordinates of LinuxCNC's world space.  The R coordinate
switchkins.c:198:        // world coords for switchkin-types
switchkins.h:19:typedef int (*KI)(const struct EmcPose * world,
tripodkins.c:30:  relative to the world frame is not computed.
tripodkins.c:90:  are no ambiguities going from world to joint coordinates.
ugenserkins.c:67:            /* world coords passed, so do iterations on inverse kins for
userkfuncs.c:63:                           struct EmcPose * world,
userkfuncs.c:73:    return identityKinematicsForward(joint,world,fflags,iflags);
