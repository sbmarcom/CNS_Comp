/* Autogenerated by /usr/bin/halcompile on Tue Apr 12 23:37:46 2022 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:proto2kins:Template for user-built kinematics");
MODULE_INFO(linuxcnc, "descr:\n.if \\n[.g] .mso www.tmac\n\nThe userkins.comp file is a template for creating\nkinematics that can be user-built using halcompile.\n\nThe unmodified userkins component can be used\nas a kinematics file for a machine with identity\nkinematics for an xyz machine employing 3 joints\n(motors).\n\n\\fBUSAGE:\\fR\n\n  1) Copy the userkins.comp file to a user-owned\n     directory (\\fBmydir\\fR).\n\n     Note: The userkins.comp file can be downloaded from:\n.URL https://github.com/LinuxCNC/linuxcnc/raw/2.8/src/hal/components/userkins.comp \n     where '2.8' is the branch name (use 'master' for\n     the master branch)\n\n     For a RIP (run-in-place) build, the file is located in\n     the git tree as:\n       src/hal/components/userkins.comp\n\n  2) Edit the functions kinematicsForward() and\n     kinematicsInverse() as required\n  3) If required, add hal pins following examples in\n     the template code\n  4) Build and install the component using halcompile:\n     $ cd \\fBmydir\\fR\n     $ [sudo] halcompile --install userkins.comp\n     # Note:\n     #      sudo is required when using a deb install\n     #      sudo is \\fBnot\\fR required for run-in-place builds\n     # $ man halcompile for more info\n  5) Specify userkins in an ini file as:\n     \\fB[KINS]\\fR\n     \\fBKINEMATICS=userkins\\fR\n     \\fBJOINTS=3\\fR\n     # the number of JOINTS must agree with the\n     # number of joints used in your modified userkins.comp\n  6) Note: the manpage for userkins is not updated by\n     halcompile --install\n  7) To use a different component name, rename the file\n     (example mykins.comp) and change all instances of\n     'userkins' to 'mykins'\n\n");
MODULE_INFO(linuxcnc, "pin:dummy:bit:0:out::1:None");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_bit_t *dummy;
};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    r = hal_pin_bit_newf(HAL_OUT, &(inst->dummy), comp_id,
        "%s.dummy", prefix);
    if(r != 0) return r;
    *(inst->dummy) = 1;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
RTAPI_MP_INT(count, "number of proto2kins");
char *names = ""; // comma separated names
RTAPI_MP_STRING(names, "names of proto2kins");
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("proto2kins");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 1];
            rtapi_snprintf(buf, sizeof(buf), "proto2kins.%d", i);
            r = export(buf, i);
            if(r != 0) break;
       }
    } else {
        int j,idx;
        char *ptr;
        char buf[HAL_NAME_LEN+1];
        ptr = names;
        idx = 0;
        for (i=0,j=0; i <= strlen(names); i++) {
            buf[j] = *(ptr+i);
            if ( (*(ptr+i) == ',') || (*(ptr+i) == 0) ) {
                buf[j] = 0;
                r = export(buf, idx);
                if (*(ptr+i+1) == 0) {break;}
                idx++;
                if(r != 0) {break;}
                j=0;
            } else {
                j++;
            }
        }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef dummy
#define dummy (*__comp_inst->dummy)


#line 56 "proto2kins.comp"

#include "rtapi.h"
#include "rtapi_math.h"
#include "rtapi_string.h"
#include "posemath.h"
#include "hal.h"
#include "kinematics.h"

static struct hal_data {
 hal_float_t *d1, *d2, *d3, *d4, *d5, *d6,*r1;
 hal_u32_t *in;
 hal_u32_t *out;

} *haldata;

#define D1 (*(haldata->d1))
#define D2 (*(haldata->d2))
#define D3 (*(haldata->d3))
#define D4 (*(haldata->d4))
#define D5 (*(haldata->d5))
#define D6 (*(haldata->d6))


#define DEFAULT_D1 490
#define DEFAULT_D2 14.75
#define DEFAULT_D3  50
#define DEFAULT_D4 16.75
#define DEFAULT_D5  50
#define DEFAULT_D6  50



static int proto2kins_setup(void) {
    int res=0;
    int comp_id;
    // this name must be different than the comp name:
    comp_id = hal_init("proto2kinsdata");

    haldata = hal_malloc(sizeof(*haldata));
    if (!haldata) goto error;

    res += hal_pin_float_newf(HAL_IN, &(haldata->d1), comp_id,"%s.D1","proto2kins");
    res += hal_pin_float_newf(HAL_IN, &(haldata->d2), comp_id,"%s.D2","proto2kins");
    res += hal_pin_float_newf(HAL_IN, &(haldata->d3), comp_id,"%s.D3","proto2kins");
    res += hal_pin_float_newf(HAL_IN, &(haldata->d4), comp_id,"%s.D4","proto2kins");
    res += hal_pin_float_newf(HAL_IN, &(haldata->d5), comp_id,"%s.D5","proto2kins");
    res += hal_pin_float_newf(HAL_IN, &(haldata->d6), comp_id,"%s.D6","proto2kins");
    if (res) { goto error; }

    //D1 = DEFAULT_D1;
    //D2 = DEFAULT_D2;
    /*D3 = DEFAULT_D3;
    D4 = DEFAULT_D4;
    D5 = DEFAULT_D5;
    D6 = DEFAULT_D6;
    
    hal_ready(comp_id);
    return 0;

error:
    return -1;}
EXPORT_SYMBOL(kinematicsType);
EXPORT_SYMBOL(kinematicsInverse);
EXPORT_SYMBOL(kinematicsForward);

KINEMATICS_TYPE kinematicsType()
{
static bool is_setup=0;
    if (!is_setup) proto2kins_setup();
    return KINEMATICS_BOTH;
} // kinematicsType()

static bool is_homed=0;
int kinematicsForward(const double *joint,
                      EmcPose * world ,
                      const KINEMATICS_FORWARD_FLAGS * fflags,
                      KINEMATICS_INVERSE_FLAGS * iflags)
{
    double a0, a1,a2 ;
    double x, y, z;

/* convert joint angles to radians for sin() and cos() */

    a0 = joint[0] * ( PM_PI / 180 );
    a1 = joint[1] * ( PM_PI / 180 );
    a2 = joint[2];
/* convert angles into world coords */
    a1 = a1 + a0;
   

    x = D2*cos(a0) + D4*cos(a1) ;
    y = D2*sin(a0) + D4*sin(a1) ;

    *iflags = 0;
    if (joint[1] < 90)
        *iflags = 1;

    world->tran.x = x;
    world->tran.y = y;
    world->tran.z = z;

    return (0);
} // kinematicsForward()

int kinematicsInverse(const  EmcPose *world,
                       double *joint,
                      const KINEMATICS_INVERSE_FLAGS * iflags,
                      KINEMATICS_FORWARD_FLAGS * fflags)
{
    double a3;
    double q0, q1;
    double xt, yt, rsq, cc;
    double x, y, z;

    x = world->tran.x;
    y = world->tran.y;
    z = world->tran.z;

    

    

    /* horizontal distance (squared) from end effector centerline
        to main column centerline */
    rsq = x*x + y*y;
    /* joint 1 angle needed to make arm length match sqrt(rsq) */
    cc = (rsq - D2*D2 - D4*D4) / (2*D2*D4);
    if(cc < -1) cc = -1;
    if(cc > 1) cc = 1;
    q1 = acos(cc);

    if (*iflags)
        q1 = -q1;

    /* angle to end effector */
    q0 = atan2(y, x);

    /* end effector coords in inner arm coord system */
    xt = D2 + D4*cos(q1);
    yt = D4*sin(q1);

    /* inner arm angle */
    q0 = q0 - atan2(yt, xt);

    /* q0 and q1 are still in radians. convert them to degrees */
    q0 = q0 * (180 / PM_PI);
    q1 = q1 * (180 / PM_PI);

    joint[0] = q0;
    joint[1] = q1+q0;
    joint[2]= z;

    *fflags = 0;

    return (0);
} // kinematicsInverse()

static int __comp_get_data_size(void) { return 0; }
